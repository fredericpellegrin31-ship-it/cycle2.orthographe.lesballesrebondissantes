<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Le Rallye du Pluriel</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Andika&family=Fredoka+One&display=swap');

        body {
            font-family: 'Andika', sans-serif;
            overflow: hidden;
            background: radial-gradient(circle, #f0fdf4 0%, #dcfce7 100%);
            margin: 0;
            touch-action: none;
            width: 100vw;
            height: 100vh;
        }

        #drawingCanvas { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: 10; 
            cursor: crosshair; 
            touch-action: none;
        }
        
        .ui-layer { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: 50; 
            pointer-events: none; 
        }

        .clickable { pointer-events: auto !important; cursor: pointer; }

        #robot-companion {
            position: fixed;
            font-size: 5rem;
            z-index: 20;
            pointer-events: none;
            transition: all 1s ease-in-out;
            animation: floating 3s ease-in-out infinite;
        }

        @keyframes floating {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(5deg); }
        }

        .screen { display: none; height: 100%; flex-direction: column; align-items: center; justify-content: center; }
        .screen.active { display: flex; }

        .btn-main {
            background: #16a34a; color: white; padding: 15px 40px;
            border-radius: 20px; font-size: 1.5rem; font-weight: bold;
            box-shadow: 0 6px 0 #15803d; transition: all 0.1s;
            border: none;
        }
        .btn-main:active { transform: translateY(4px); box-shadow: none; }

        .sentence-container {
            position: absolute; top: 55%; left: 50%;
            transform: translate(-50%, -50%); width: 95%;
            display: flex; justify-content: center; align-items: baseline;
            gap: 1rem; flex-wrap: wrap; 
        }
        .word { font-size: 3.2rem; color: #164e63; position: relative; line-height: 2; user-select: none; }
        .level-3 .word { font-size: 2.3rem; } 

        .target-zone { position: relative; padding: 0 4px; border-radius: 8px; display: inline-block; }
        .suffix-zone { min-width: 0.8ch; display: inline-block; }
        
        .level-1 .suffix-zone:not(.revealed) { border-bottom: 3px dashed #94a3b8; color: transparent; }
        .level-2 .suffix-zone:not(.revealed), .level-3 .suffix-zone:not(.revealed) { color: transparent; border-bottom: none !important; }
        
        .revealed { color: #16a34a !important; font-weight: bold; border-bottom: none !important; animation: pop 0.4s ease-out; }
        .success-highlight { color: #16a34a !important; font-weight: bold; }

        @keyframes pop { 0% { transform: scale(0); } 80% { transform: scale(1.4); } 100% { transform: scale(1); } }

        .instruction-box {
            position: absolute; top: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(255,255,255,0.95); padding: 15px 30px; border-radius: 50px;
            border: 5px solid #16a34a; box-shadow: 0 10px 20px rgba(0,0,0,0.1);
            font-weight: bold; font-size: 1.6rem; color: #14532d;
            text-align: center; width: 85%; max-width: 700px;
        }
    </style>
</head>
<body>

    <div id="robot-companion">ü§ñ</div>
    <canvas id="drawingCanvas"></canvas>

    <div class="ui-layer">
        <div id="homeScreen" class="screen active">
            <h1 class="text-6xl font-bold text-green-900 mb-12 text-center" style="font-family: 'Fredoka One'; text-shadow: 2px 2px #fff; pointer-events: none;">Le Rallye du Pluriel</h1>
            
            <div class="flex flex-col gap-6">
                <button class="btn-main clickable bg-amber-500 shadow-amber-700 mb-4" onclick="showModal('lessonModal')">üìñ Voir la le√ßon</button>
                <div class="flex gap-4">
                    <button class="btn-main clickable" onclick="startGame(1)">Niveau 1</button>
                    <button class="btn-main clickable" onclick="startGame(2)">Niveau 2</button>
                    <button class="btn-main clickable" onclick="startGame(3)">Niveau 3</button>
                </div>
            </div>
        </div>

        <div id="gameScreen" class="screen">
            <div id="instruction" class="instruction-box">Entoure le d√©terminant</div>
            <div id="progressText" class="absolute top-24 md:top-6 right-10 text-2xl font-bold text-green-900"></div>
            <div id="gameSentence" class="sentence-container"></div>

            <div class="absolute bottom-10 left-10 flex gap-4">
                <button class="btn-main clickable bg-slate-600 shadow-slate-800" onclick="goHome()">üè† Menu</button>
            </div>

            <button id="nextBtn" class="btn-main clickable bg-blue-500 shadow-blue-700 absolute bottom-10 right-10 hidden" onclick="nextQuestion()">Phrase suivante ‚ûú</button>
        </div>
    </div>

    <div id="lessonModal" class="fixed top-0 left-0 w-full h-full bg-black/80 z-[2000] hidden items-center justify-center pointer-events-auto">
        <div class="bg-white p-8 rounded-3xl w-11/12 max-w-4xl flex flex-col items-center">
            <h2 class="text-3xl font-bold mb-4 text-green-900">Le√ßon : L'accord dans le groupe nominal</h2>
            <div class="w-full aspect-video mb-6 bg-black rounded-xl overflow-hidden">
                <iframe id="lessonIframe" width="100%" height="100%" frameborder="0" allowfullscreen></iframe>
            </div>
            <button class="btn-main clickable" onclick="closeModal('lessonModal')">J'ai compris !</button>
        </div>
    </div>

    <script>
        // Mots √† ignorer (invariables qui finissent par s/x)
        const invariables = ["dans", "vers", "sous", "sans", "mais", "puis", "alors", "toujours", "plus", "bas", "souvent", "depuis", "tr√®s", "apr√®s", "pas"];

        const rawData = {
            1: ["Les chats", "Des chiens", "Mes stylos", "Tes livres", "Ses amis", "Nos jeux", "Vos mains", "Leurs v√©los", "Les pommes", "Des ballons"],
            2: ["Les petits chats", "Des grands chiens", "Mes nouveaux stylos", "Tes jolis livres", "Ses meilleurs amis", "Nos vieux jeux", "Vos blanches mains", "Leurs beaux v√©los"],
            3: [
                "Les chats noirs dorment dans des paniers", 
                "Des chiens gourmands mangent toujours des gros os", 
                "Les enfants joyeux jouent sous les arbres", 
                "Mes parents ach√®tent des fruits frais vers midi", 
                "Ses fr√®res sportifs lisent des petits livres",
                "Les belles fleurs rouges d√©corent les jardins",
                "Des √©normes camions bleus bloquent les routes sans arr√™t",
                "Tes vieux habits sales tra√Ænent dans les chambres",
                "Leurs meilleurs amis fid√®les arrivent ce soir",
                "Nos petites s≈ìurs attentives √©coutent des histoires",
                "Vos grands ballons color√©s volent dans les airs",
                "Des nouveaux √©l√®ves s√©rieux travaillent beaucoup",
                "Les jolis petits oiseaux chantent dans les bois",
                "Des mauvaises herbes s√®ches poussent partout sous la pluie",
                "Mes chers cousins lointains √©crivent des lettres depuis longtemps"
                "Des crayons cass√©s tra√Ænent sur la table de travail."
                "Les √©l√®ves curieux posent des questions int√©ressantes."
                "Des affiches color√©es d√©corent les murs de la classe."
               "Les fr√®res jumeaux regardent un dessin anim√© dr√¥le"
                "Des √©toiles brillantes illuminent le ciel nocturne."
               "Les parents attentifs √©coutent la ma√Ætresse de la classe."
                "Des chaussures mouill√©es s√®chent pr√®s de la porte d‚Äôentr√©e."
                "Des poissons color√©s nagent dans le grand aquarium."
                "Des nuages sombres cachent le soleil d‚Äô√©t√©."
                "Les √©l√®ves attentifs lisent une histoire passionnante."
                "Des feuilles mortes recouvrent le sol humide."
                "Les joueurs fatigu√©s quittent le terrain boueux."
                "Mes cousins visitent le mus√©e de la ville."
                "Des cadeaux emball√©s attendent sous le sapin d√©cor√©."
            ]
        };

        let currentLevel = 1, currentIdx = 0, levelQueue = [];
        let progress = { dets: [], bridges: [], suffixes: [] };
        let isDrawing = false, points = [];
        let screenMode = 'home';

        const robot = document.getElementById('robot-companion');
        const drawingCanvas = document.getElementById('drawingCanvas');
        const ctx = drawingCanvas.getContext('2d');

        function parseSentence(str) {
            const parts = str.split(' ');
            let lastDetIdx = -1;
            let currentGN = [];

            const parsed = parts.map((w, i) => {
                const clean = w.toLowerCase().replace(/[.,!]/g, '');
                
                // D√©tection d√©terminant pluriel
                if(["les","des","mes","tes","ses","nos","vos","leurs","ces"].includes(clean)) {
                    lastDetIdx = i;
                    currentGN = [i];
                    return {t:w, type:'det', id: i};
                }
                
                // D√©tection accord (Nom/Adj)
                // Condition : doit finir par s/x, ne pas √™tre invariable, et suivre un d√©terminant
                if(lastDetIdx !== -1 && (clean.endsWith('s') || clean.endsWith('x')) && !invariables.includes(clean) && clean !== "os" && clean !== "aux") {
                    const obj = {t:w, root: w.slice(0,-1), s: w.slice(-1), type:'adj_noun', linkedTo: lastDetIdx, id: i};
                    currentGN.push(i);
                    return obj;
                }
                
                // Si on croise un mot qui casse le GN (verbe, pr√©position, etc.)
                if(lastDetIdx !== -1 && !clean.endsWith('s') && !clean.endsWith('x') && clean !== "et") {
                    // On ne r√©initialise pas forc√©ment pour permettre Adj + Nom (ex: petits chats)
                    // Mais on marque que ce mot n'est pas une cible
                }

                return {t:w, type:'txt', id: i};
            });

            return { p: parsed };
        }

        function startGame(lvl) {
            screenMode = 'game';
            currentLevel = lvl;
            levelQueue = [...rawData[lvl]]
                .sort(() => Math.random() - 0.5)
                .slice(0, 10)
                .map(s => parseSentence(s));
            
            currentIdx = 0;
            document.getElementById('homeScreen').classList.remove('active');
            const gScreen = document.getElementById('gameScreen');
            gScreen.classList.add('active');
            gScreen.className = `screen active level-${lvl}`;
            updateRobotPosition();
            loadQuestion();
        }

        function loadQuestion() {
            const data = levelQueue[currentIdx];
            progress = { dets: [], bridges: [], suffixes: [] };
            document.getElementById('progressText').innerText = `Phrase ${currentIdx+1}/10`;
            const cont = document.getElementById('gameSentence');
            cont.innerHTML = '';
            
            data.p.forEach((p, i) => {
                const span = document.createElement('span');
                span.className = 'word';
                if(p.type === 'det') {
                    span.innerHTML = `<span class="target-zone det" data-idx="${i}">${p.t}</span>`;
                } else if(p.type === 'adj_noun') {
                    let placeholder = (currentLevel === 1) ? "_" : " ";
                    span.innerHTML = `${p.root}<span class="target-zone suffix suffix-zone" data-idx="${i}" data-val="${p.s}">${placeholder}</span>`;
                } else {
                    span.innerText = p.t;
                }
                cont.appendChild(span);
            });
            document.getElementById('nextBtn').classList.add('hidden');
            ctx.clearRect(0,0,drawingCanvas.width, drawingCanvas.height);
            updateInstruction();
        }

        function updateInstruction() {
            const instr = document.getElementById('instruction');
            const data = levelQueue[currentIdx];
            const dets = data.p.filter(p => p.type === 'det');
            const suffixes = data.p.filter(p => p.type === 'adj_noun');

            if(currentLevel === 3) {
                if(progress.dets.length === dets.length && progress.bridges.length === suffixes.length && progress.suffixes.length === suffixes.length) {
                    instr.innerText = "Parfait ! C'est gagn√© !";
                    document.getElementById('nextBtn').classList.remove('hidden');
                    confetti({ particleCount: 100, spread: 70, origin: { y: 0.6 } });
                } else {
                    instr.innerText = "√Ä toi de jouer ! Accorde tout le monde.";
                }
                return;
            }

            if(progress.dets.length < dets.length) {
                instr.innerText = "√âtape 1 : Entoure le d√©terminant";
            } else if(progress.bridges.length < suffixes.length || progress.suffixes.length < suffixes.length) {
                instr.innerText = "√âtape 2 : Fais les ponts et entoure les marques (s/x)";
            } else {
                instr.innerText = "Bravo ! Tu as fini la phrase.";
                document.getElementById('nextBtn').classList.remove('hidden');
                confetti({ particleCount: 100, spread: 70, origin: { y: 0.6 } });
            }
        }

        function updateRobotPosition() {
            if(screenMode === 'home') {
                robot.style.top = '15%'; robot.style.left = '80%';
            } else {
                robot.style.top = '8%'; robot.style.left = '5%';
            }
        }

        function handleStart(e) {
            if (screenMode !== 'game') return;
            isDrawing = true;
            const x = e.touches ? e.touches[0].clientX : e.clientX;
            const y = e.touches ? e.touches[0].clientY : e.clientY;
            points = [{x, y}];
        }

        function handleMove(e) {
            if(!isDrawing) return;
            const x = e.touches ? e.touches[0].clientX : e.clientX;
            const y = e.touches ? e.touches[0].clientY : e.clientY;
            points.push({x, y});
            
            redrawAll();
            ctx.strokeStyle = '#94a3b8'; 
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for(let i=1; i<points.length; i++) ctx.lineTo(points[i].x, points[i].y);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function handleEnd() {
            if(!isDrawing) return;
            isDrawing = false;
            checkAction();
            redrawAll();
            points = [];
        }

        function checkAction() {
            if(points.length < 5) return;
            const bounds = getPointsBounds(points);
            const mid = { x: (bounds.minX + bounds.maxX)/2, y: (bounds.minY + bounds.maxY)/2 };
            const data = levelQueue[currentIdx];

            // 1. D√©terminant
            const targetDet = Array.from(document.querySelectorAll('.det')).find(el => !progress.dets.includes(el.dataset.idx));
            if(targetDet && isInside(mid, targetDet.getBoundingClientRect())) {
                progress.dets.push(targetDet.dataset.idx);
                targetDet.classList.add('success-highlight');
                return updateInstruction();
            }

            // 2. Accords
            const suffixes = Array.from(document.querySelectorAll('.suffix'));
            
            const suffixToCircle = suffixes.find(el => !progress.suffixes.includes(el.dataset.idx));
            if(suffixToCircle) {
                const tIdx = parseInt(suffixToCircle.dataset.idx);
                const detIdx = data.p[tIdx].linkedTo;
                if(progress.dets.includes(String(detIdx)) && isInside(mid, suffixToCircle.getBoundingClientRect())) {
                    progress.suffixes.push(suffixToCircle.dataset.idx);
                    suffixToCircle.classList.add('revealed');
                    suffixToCircle.innerText = suffixToCircle.dataset.val;
                    return updateInstruction();
                }
            }

            const suffixToBridge = suffixes.find(el => !progress.bridges.some(b => b.to === el.dataset.idx));
            if(suffixToBridge) {
                const tIdx = parseInt(suffixToBridge.dataset.idx);
                const detIdx = data.p[tIdx].linkedTo;
                if(progress.dets.includes(String(detIdx))) {
                    let sIdx = detIdx;
                    const chain = data.p.map((p,i)=>({...p, i})).filter(p => p.linkedTo === detIdx || p.i === detIdx);
                    const myPos = chain.findIndex(g => g.i === tIdx);
                    if(myPos > 0) sIdx = chain[myPos-1].i;

                    const startEl = document.querySelector(`[data-idx="${sIdx}"]`);
                    const startRect = startEl.getBoundingClientRect();
                    const endRect = suffixToBridge.closest('.word').getBoundingClientRect();
                    
                    if(dist(points[0], startRect) < 150 && dist(points[points.length-1], endRect) < 150) {
                        progress.bridges.push({from: String(sIdx), to: suffixToBridge.dataset.idx});
                        return updateInstruction();
                    }
                }
            }
        }

        function redrawAll() {
            ctx.clearRect(0,0,drawingCanvas.width, drawingCanvas.height);
            ctx.lineWidth = 5; ctx.strokeStyle = '#16a34a'; ctx.lineCap = 'round'; ctx.lineJoin = 'round';

            progress.dets.forEach(idx => {
                const el = document.querySelector(`.det[data-idx="${idx}"]`);
                if(el) {
                    const r = el.getBoundingClientRect();
                    ctx.beginPath();
                    ctx.ellipse(r.left + r.width/2, r.top + r.height/2, (r.width/2) + 20, (r.height/2) + 15, 0, 0, Math.PI*2);
                    ctx.stroke();
                }
            });

            progress.suffixes.forEach(idx => {
                const el = document.querySelector(`.suffix[data-idx="${idx}"]`);
                if(el) {
                    const r = el.getBoundingClientRect();
                    ctx.beginPath();
                    ctx.ellipse(r.left + r.width/2, r.top + r.height/2, 35, 30, 0, 0, Math.PI*2);
                    ctx.stroke();
                }
            });

            progress.bridges.forEach(b => {
                const startEl = document.querySelector(`[data-idx="${b.from}"]`);
                const endEl = document.querySelector(`[data-idx="${b.to}"]`);
                if(!startEl || !endEl) return;
                const start = startEl.getBoundingClientRect();
                const end = endEl.getBoundingClientRect();
                ctx.beginPath();
                ctx.moveTo(start.left + start.width/2, start.top);
                ctx.quadraticCurveTo((start.left + end.left)/2, Math.min(start.top, end.top) - 70, end.left + end.width/2, end.top);
                ctx.stroke();
            });
        }

        function getPointsBounds(pts) {
            let minX=9999, minY=9999, maxX=0, maxY=0;
            pts.forEach(p=>{ minX=Math.min(minX,p.x); minY=Math.min(minY,p.y); maxX=Math.max(maxX,p.x); maxY=Math.max(maxY,p.y); });
            return {minX, minY, maxX, maxY};
        }
        function isInside(p, r) { return p.x > r.left-30 && p.x < r.right+30 && p.y > r.top-30 && p.y < r.bottom+30; }
        function dist(p, r) { const cx=r.left+r.width/2, cy=r.top+r.height/2; return Math.hypot(p.x-cx, p.y-cy); }

        function showModal(id) { 
            document.getElementById(id).style.display = 'flex'; 
            if(id === 'lessonModal') document.getElementById('lessonIframe').src = "https://lesfondamentaux.reseau-canope.fr:/embed/video/accord-en-nombre-determinant-nom-commun-15"; 
        }
        function closeModal(id) { 
            document.getElementById(id).style.display = 'none'; 
            document.getElementById('lessonIframe').src = ""; 
        }
        
        function goHome() { 
            screenMode = 'home'; 
            document.getElementById('gameScreen').classList.remove('active'); 
            document.getElementById('homeScreen').classList.add('active'); 
            updateRobotPosition();
            ctx.clearRect(0,0,drawingCanvas.width, drawingCanvas.height);
        }
        
        function nextQuestion() { 
            currentIdx++; 
            if(currentIdx >= levelQueue.length) {
                confetti({ particleCount: 200, spread: 100, origin: { y: 0.5 } });
                setTimeout(goHome, 2000);
            } else loadQuestion(); 
        }

        window.onload = () => { 
            drawingCanvas.width = window.innerWidth; 
            drawingCanvas.height = window.innerHeight; 
            updateRobotPosition();
        };
        window.onresize = () => { 
            drawingCanvas.width = window.innerWidth; 
            drawingCanvas.height = window.innerHeight; 
        };

        drawingCanvas.addEventListener('mousedown', handleStart);
        drawingCanvas.addEventListener('mousemove', handleMove);
        window.addEventListener('mouseup', handleEnd);
        
        drawingCanvas.addEventListener('touchstart', (e) => { handleStart(e); }, {passive: false});
        drawingCanvas.addEventListener('touchmove', (e) => { if(isDrawing) { e.preventDefault(); handleMove(e); } }, {passive: false});
        window.addEventListener('touchend', handleEnd);
    </script>
</body>
</html>

